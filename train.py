"""
Use train.py to train cyclegan.
All parameters you need are set in `Params`,you can reset it for your need.
"""

import time
from params.params import Params
from data import load_data
from model.cycleModel import cycleGAN

if __name__ == "__main__":
    params = Params()
    dataset = load_data(params) #load data
    data_size = len(dataset)
    print('Creat Model: cycleGAN')
    model = cycleGAN(params) #creat model and init it.
    model.load() #load the latest model or the epoch of model including optimizers,epoch,losses.
    total_iters = 0
    print("Start to train the model")
    for epoch in range(model.epoch,params.n_epoch+1):
        start = time.time()
        epoch_iters = 0

        for i,data in enumerate(dataset):
            total_iters += params.batch_size
            epoch_iters += params.batch_size
            model.set_input(data) #input data 
            print('Epoch : {}'.format(epoch))
            model.step() #train the model

            if total_iters % params.print_freq == 0:
                continue
            if total_iters % params.save_lasted_freq == 0:
                print('Saving the latest model')
                pre = 'latest'
                model.save_model(pre) #save the model and other necessary states for training later.
                print('Latest model saved')
        if epoch % params.save_epoch_freq == 0:
            model.save_model('latest')
            model.save_model(epoch) #save the model and other necessary states for training later. 
           #save_samples(model,params) #save the samples generated by Generate_A or Generator_B 
        end = time.time()
        print('{}/{} is Done! Time Taken: {:.4f}s'.format(epoch,params.n_epoch,end-start))
        m = ''
        for name,value in model.losses.items():
            m += str(name)+" : "+str(round(value[-1],8))
        print("latest loss information,{}".format(m))
        model.update_learning_rate() #update learning rate







